const url = require("url")
const axios = require("axios")

const globalVariables = require("./variables")
const errors = require("./errors")
const parser = require("./parser")

async function videoInfo(videoUrl, givenOptions = {}) {
    const options = {
      includeRawData: givenOptions.includeRawData != undefined ? givenOptions.includeRawData : false,
      bypassIdCheck: givenOptions.bypassIdCheck != undefined ? givenOptions.bypassIdCheck : false
    }

    const videoIdRegex = /^[0-9A-Za-z_-]{10,}[048AEIMQUYcgkosw]$/g
    let videoId

    if (videoIdRegex.test(videoUrl)) {
      videoId = videoUrl
    } else {
      const httpRegex = /^(http|https):\/\//g
      if (!httpRegex.test(videoUrl)) {
        videoUrl = "https://" + videoUrl
      }

      const parsedUrl = url.parse(videoUrl)

      if (/^(www.)?youtube.com/g.test(parsedUrl.hostname)) {
        const urlQueries = {}
        parsedUrl.query.split("&").forEach(query => {
          const split = query.split("=")
          urlQueries[split[0]] = split[1]
        })

        if (!urlQueries.v) {
          throw new errors.YTScraperInvalidVideoURL()
        }

        if (!videoIdRegex.test(urlQueries.v)) {
          if (!options.bypassIdCheck) {
            throw new errors.YTScraperInvalidVideoID()
          }
        }

        videoId = urlQueries.v
      } else if (/^youtu.be/g.test(parsedUrl.hostname)) {
        const pathnameId = parsedUrl.pathname.slice(1,)

        if (pathnameId.length <= 0) {
          throw new errors.YTScraperInvalidVideoURL()
        }

        if (!videoIdRegex.test(pathnameId)) {
          if (!options.bypassIdCheck) {
            throw new errors.YTScraperInvalidVideoID()
          }
        }

        videoId = pathnameId
      } else {
        throw new errors.YTScraperInvalidVideoURL()
      }
    }

    const ytUrl = `https://www.youtube.com/watch?v=${videoId}&gl=US&hl=en&has_verified=1&bpctr=9999999999`

    const { data } = await axios.get(ytUrl, { headers: globalVariables.headers })
    if (!data) {
      throw new errors.YTScraperMissingData()
    }

    var extractedPageData = await parser.parsePageData(data)
     
    function parseScrapedCount(count) {
      const parsed = parseInt(count.toLowerCase().replace(/k/g, "000").replace(/m/g, "000000").replace(/b/g, "000000000").replace(/,/g, ""))
      return parsed == NaN ? undefined : parsed
    }

    function parseScrapedDate(dateString) {
      if (!dateString) {
        return undefined
      }

      const parsed = new Date(dateString)
      if (parsed == "Invalid Date") {
        return undefined
      }

      return parsed
    }

    function parseScrapedLikeCount(count) {
      const parsed = parseInt(count.replace(/[^0-9]/g, ""))
      return parsed == NaN ? undefined : parsed
    }

    function parseScrapedInt(intString) {
      if (!intString) {
        return undefined
      }

      const parsed = parseInt(intString)
      return parsed == NaN ? undefined : parsed
    }

    const videoDetails = extractedPageData.videoDetails
    if (!videoDetails) {
      throw new errors.YTScraperMissingData()
    }

    const microformatDetails = extractedPageData.microformat.playerMicroformatRenderer

    let metadata = {
      id: videoDetails.videoId,
      url: `https://www.youtube.com/watch?v=${videoId}`,
      title: videoDetails.title,
      views: parseScrapedInt(videoDetails.viewCount),
      description: microformatDetails.description ? microformatDetails.description.simpleText : undefined,
      category: microformatDetails.category,
      length: parseScrapedInt(microformatDetails.lengthSeconds),
      thumbnails: microformatDetails.thumbnail ? microformatDetails.thumbnail.thumbnails : undefined,
      live: videoDetails.isLiveContent,
      privacy: {
        private: videoDetails.isPrivate,
        unlisted: microformatDetails.isUnlisted,
        familySafe: microformatDetails.isFamilySafe,
        availableCountries: microformatDetails.availableCountries
      },
      dates: {
        published: parseScrapedDate(microformatDetails.publishDate),
        uploaded: parseScrapedDate(microformatDetails.uploadDate)
      },
      streams: {
        formats: extractedPageData.streamingData.formats,
        adaptiveFormats: extractedPageData.streamingData.adaptiveFormats
      }
      
    }

    if (options.includeRawData) {
      metadata.raw = extractedPageData
    }

    return metadata
}

exports.info = videoInfo